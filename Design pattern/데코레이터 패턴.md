# Decorator pattern
데코레이터 패턴은 기존 뼈대는 유지하되, 이후 필요한 형태로 꾸밀 때 사용한다.<br>
상속보다 유연한 구현 방식으로, 확장이 필요한 경우 상속의 대안으로도 활용된다.<br>
SOLID 중에서 개발 폐쇄 원칙(OCP) 과 의존 역전 원칙(DIP) 를 따른다.<br>
예를 들어, 아메리카노에 우유를 추가하면 카페 라떼, 라떼에 모카 시럽을 추가하면 모카 라떼 가 되는 커피 프로그램이라면 데코레이터 패턴을 활용할 수 있다.<br>
여기서 아메리카노는 컴포넌트고, 우유, 시럽은 데코레이터 이다.

#### Coffee.java
```아메리카노``` ```컴포넌트```
```
public abstract class Coffee {
	public abstract void brewing();
}
```
#### Decorator.java
```
public abstract class Decorator extends Coffee{

	Coffee coffee;
	public Decorator(Coffee coffee){
		this.coffee = coffee;
	}
	
	@Override
	public void brewing() {
		coffee.brewing();
	}
}
```
#### Latte.java
```우유``` ```데코레이터```
```
public class Latte extends Decorator{

	public Latte(Coffee coffee) {
		super(coffee);
	}
  
	public void brewing() {
		super.brewing();
		System.out.print("Adding Milk ");
	}
}
```
#### Mocha.java
```시럽``` ```데코레이터```
```
public class Mocha extends Decorator{

	public Mocha(Coffee coffee) {
		super(coffee);
	}

	public void brewing() {
		super.brewing();
		System.out.print("Adding Mocha Syrup ");
	}
}
```

데코레이터 패턴은 지속적인 기능의 추가 또는 제거에 용이하다.

만약 다른 메뉴가 새로 생기더라도 간단하게 추가할 수 있다.

#### WhippedCream.java
```새로운 메뉴 추가``` ```휘핑 크림``` ```데코레이터```
```
public class WhippedCream extends Decorator{

	public WhippedCream(Coffee coffee) {
		super(coffee);
	}

	public void brewing() {
		super.brewing();
		System.out.print("Adding WhippedCream ");
	}
}
```
